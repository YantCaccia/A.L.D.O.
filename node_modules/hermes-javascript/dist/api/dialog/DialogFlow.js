"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Dialog flow session manager.
 */
class DialogFlow {
    /**
     * @internal **For internal use only**
     * @param dialog - Dialog instance.
     * @param sessionId - The session id to manage.
     * @param done - A callback to perform when the session ends.
     */
    constructor(dialog, sessionId, done) {
        this.dialog = dialog;
        this.sessionId = sessionId;
        this.continuations = new Map();
        this.continuationsListeners = new Map();
        this.notRecognizedAction = null;
        this.notRecognizedListener = null;
        this.ended = false;
        this.slotFiller = null;
        // Sets up a subscriber to clean up in case the session is ended programatically.
        const onSessionEnded = (msg) => {
            if (msg && msg.sessionId === this.sessionId) {
                this.cleanUpListeners();
                this.reset();
                this.sessionId = null;
                done();
            }
        };
        this.dialog.once('session_ended', onSessionEnded);
    }
    reset() {
        this.continuations = new Map();
        this.continuationsListeners = new Map();
        this.notRecognizedAction = null;
        this.notRecognizedListener = null;
        this.ended = false;
        this.slotFiller = null;
    }
    cleanUpListeners() {
        this.continuationsListeners.forEach((listener, intentName) => {
            this.dialog.off(`intent/${intentName}`, listener);
        });
        if (this.notRecognizedListener) {
            this.dialog.off('intent_not_recognized', this.notRecognizedListener);
        }
    }
    // Executed after a message callback has been processed.
    continuation(options = {}, { sessionStart = false } = {}) {
        let messageOptions = {};
        if (typeof options === 'string') {
            messageOptions = { text: options };
        }
        else if (typeof options === 'object') {
            messageOptions = options;
        }
        if (this.ended) {
            // End the session.
            return this.dialog.publish('end_session', Object.assign(Object.assign({ text: '' }, messageOptions), { sessionId: this.sessionId }));
        }
        let intentFilter = [];
        if (this.continuations.size > 0) {
            // If continue calls have been registered.
            this.continuations.forEach((action, intentName) => {
                intentFilter.push(intentName);
                const listener = this.createListener(action);
                const wrappedListener = this.dialog.once(`intent/${intentName}`, listener);
                this.continuationsListeners.set(intentName, wrappedListener);
            });
        }
        if (this.notRecognizedAction) {
            // If a listener has been set in case the intent has not been properly detected
            const listener = this.createListener(this.notRecognizedAction);
            const wrappedListener = this.dialog.once('intent_not_recognized', listener);
            this.notRecognizedListener = wrappedListener;
            messageOptions.sendIntentNotRecognized = true;
        }
        if (!sessionStart) {
            // Publish a continue session message
            this.dialog.publish('continue_session', Object.assign(Object.assign({ text: '' }, messageOptions), { slot: this.slotFiller, sessionId: this.sessionId, intentFilter }));
        }
    }
    createListener(action) {
        return (message) => {
            // Checks the session id
            if (message.sessionId !== this.sessionId)
                return;
            // Cleans up other listeners that could have been registered using .continue
            this.cleanUpListeners();
            // Resets the state
            this.reset();
            // Exposes .continue / .end / .notRecognized
            const flow = {
                continue: this.continue.bind(this),
                notRecognized: this.notRecognized.bind(this),
                end: this.end.bind(this)
            };
            // Perform the message callback, then continue the flow
            return Promise.resolve(action(message, flow))
                .then(this.continuation.bind(this));
        };
    }
    /**
     * @internal **For internal use only.**
     *
     * Starts a dialog flow.
     *
     * @param action - Action to perform on flow creation.
     * @param message - The message received on flow creation.
     * @param options - Internal options.
     */
    start(action, message, { sessionStart = false } = {}) {
        const flow = {
            continue: this.continue.bind(this),
            notRecognized: this.notRecognized.bind(this),
            end: this.end.bind(this)
        };
        return Promise.resolve(action(message, flow))
            .then((...args) => this.continuation.bind(this)(...args, { sessionStart }));
    }
    // Registers an intent filter and continue the current dialog session.
    continue(intentName, action, continueOptions = { slotFiller: null }) {
        this.slotFiller = continueOptions.slotFiller;
        this.continuations.set(intentName, action);
    }
    // Registers a listener that will be called if no intents have been recognized.
    notRecognized(action) {
        this.notRecognizedAction = action;
    }
    // Terminates the dialog session.
    end() {
        this.ended = true;
    }
}
exports.default = DialogFlow;
module.exports = DialogFlow;
//# sourceMappingURL=DialogFlow.js.map