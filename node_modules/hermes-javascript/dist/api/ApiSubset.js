"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ffi_1 = __importDefault(require("ffi"));
const ref_1 = __importDefault(require("ref"));
/* Tools */
const getMetadata = function (obj, eventName) {
    if (typeof eventName === 'symbol')
        throw new Error('Symbol not expected');
    let metadata = obj[eventName];
    if (!metadata) {
        const matchingEntry = Object
            .entries(obj)
            .find(([key]) => typeof eventName === 'string' && eventName.startsWith(key));
        if (matchingEntry) {
            metadata = matchingEntry[1];
        }
        else {
            throw new Error(eventName + ' is not a known event!');
        }
    }
    return metadata;
};
/**
 * An abstract Hermes API subset.
 */
class ApiSubset {
    constructor(protocolHandler, call, options, facadeName) {
        this.listeners = new Map();
        this.ffiCallbacks = new Map();
        this.facade = null;
        this.subscribeEvents = {};
        this.publishEvents = {};
        this.publishMessagesList = {};
        this.subscribeMessagesList = {};
        this.call = call;
        this.options = options;
        this.listeners = new Map();
        if (facadeName && protocolHandler) {
            const facadeRef = ref_1.default.alloc('void **');
            this.call(facadeName, protocolHandler, facadeRef);
            this.facade = facadeRef.deref();
        }
    }
    destroy() { }
    makeSubscriptionCallback(eventName) {
        return ffi_1.default.Callback('void', [ref_1.default.coerceType('string')], (stringifiedJson) => {
            try {
                const message = JSON.parse(stringifiedJson);
                const actions = this.listeners.get(eventName);
                actions.forEach(action => action(message));
            }
            catch (err) {
                // eslint-disable-next-line
                console.error(err);
                throw err;
            }
        });
    }
    /**
     * Subscribes a message listener to a given hermes event.
     *
     * @param eventName - The event name to subscribe to.
     * @param listener - A callback triggered when receiving a message.
     * @returns A reference to the listener.
     */
    on(eventName, listener) {
        const { fullEventName, additionalArguments } = getMetadata(this.subscribeEvents, eventName);
        let listeners = this.listeners.get(eventName);
        if (!listeners) {
            listeners = [];
            this.listeners.set(eventName, listeners);
            const callback = this.makeSubscriptionCallback(eventName);
            const args = [
                ...(additionalArguments && additionalArguments(eventName) || []),
                callback
            ];
            // Prevent GC
            this.ffiCallbacks.set(eventName, callback);
            this.call(fullEventName, this.facade, ...args);
        }
        listeners.push(listener);
        return listener;
    }
    /**
     * Add a message listener that will only get called **once** for a given hermes event, then unsubscribe.
     *
     * @param eventName - The event name to subscribe to.
     * @param listener - A callback triggered when receiving a message.
     * @returns A reference to the wrapped listener.
     */
    once(eventName, listener) {
        const listenerWrapper = (message, ...args) => {
            this.off(eventName, listenerWrapper);
            listener(message, ...args);
        };
        this.on(eventName, listenerWrapper);
        return listenerWrapper;
    }
    /**
     * Removes an existing message listener for a given hermes event.
     *
     * @param eventName - The event name that was subscribed to.
     * @param listener - A reference to the listener callback to remove.
     * @returns True if succeeded, false otherwise.
     */
    off(eventName, listener) {
        const listeners = this.listeners.get(eventName);
        if (!listeners)
            return false;
        const index = listeners.indexOf(listener);
        if (index < 0)
            return false;
        listeners.splice(index, 1);
        return true;
    }
    /**
     * Publish a message.
     *
     * @param eventName - Name of the publishing event.
     * @param message - Contents of the message.
     */
    publish(eventName, message) {
        const { fullEventName } = getMetadata(this.publishEvents, eventName);
        if (message) {
            const cStringRef = ref_1.default.allocCString(JSON.stringify(message));
            this.call(fullEventName, this.facade, cStringRef);
        }
        else {
            this.call(fullEventName, this.facade);
        }
    }
}
exports.default = ApiSubset;
//# sourceMappingURL=ApiSubset.js.map