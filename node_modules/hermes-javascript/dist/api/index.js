"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ref_1 = __importDefault(require("ref"));
const dialog_1 = __importDefault(require("./dialog"));
exports.Dialog = dialog_1.default;
const injection_1 = __importDefault(require("./injection"));
exports.Injection = injection_1.default;
const feedback_1 = __importDefault(require("./feedback"));
exports.Feedback = feedback_1.default;
const audio_1 = __importDefault(require("./audio"));
exports.Audio = audio_1.default;
const tts_1 = __importDefault(require("./tts"));
exports.Tts = tts_1.default;
const casts_1 = require("../casts");
const bindings_1 = require("../ffi/bindings");
const ApiSubset_1 = __importDefault(require("./ApiSubset"));
exports.ApiSubset = ApiSubset_1.default;
__export(require("./types"));
/**
 * Hermes javascript is an high level API that allows you to
 * subscribe and send Snips messages using the Hermes protocol.
 *
 * **Important: do not instantiate this class more than once!**
 */
class Hermes {
    /**
     * Create a new Hermes instance that connects to the underlying event bus.
     *
     * **Important: Each call to this function will open the hermes shared library
     * and bind hermes-javascript to it. It is an expensive operation.**
     *
     * @param options - Options used to instantiate a new Hermes object.
     */
    constructor(options = {}) {
        this.activeSubsets = new Map();
        // Initialize a new Hermes instance.
        this.options = Object.assign(Object.assign({}, Hermes.defaultOptions), options);
        this.call = bindings_1.call(this.options.libraryPath);
        // Allocate the ProtocolHandler double reference
        const protocolHandlerRef = ref_1.default.alloc('void **');
        // Allocate mqtt broker options
        const mqttOptions = new casts_1.MqttOptions({
            broker_address: this.options.address,
            username: this.options.username,
            password: this.options.password,
            tls_hostname: this.options.tls_hostname,
            tls_ca_file: this.options.tls_ca_file,
            tls_ca_path: this.options.tls_ca_path,
            tls_client_key: this.options.tls_client_key,
            tls_client_cert: this.options.tls_client_cert,
            tls_disable_root_store: this.options.tls_disable_root_store
        });
        const mqttOptionsStructPtr = mqttOptions.forge().ref();
        ref_1.default._attach(mqttOptionsStructPtr, this);
        // Connect to MQTT with the specified options
        this.call('hermes_protocol_handler_new_mqtt_with_options', protocolHandlerRef, mqttOptionsStructPtr, ref_1.default.NULL_POINTER);
        this.protocolHandler = protocolHandlerRef.deref();
        // Extra API call to enable logs if needed
        if (this.options.logs) {
            this.call('hermes_enable_debug_logs');
        }
    }
    /**
     * Return a Dialog instance used to interact with the dialog API.
     *
     * @returns A Dialog instance, reused from a previous call if possible.
     */
    dialog() {
        return this._getOrCreateSubset('dialog', dialog_1.default);
    }
    /**
     * Return an Injection instance used to interact with the vocabulary injection API.
     *
     * @returns An Injection instance, reused from a previous call if possible.
     */
    injection() {
        return this._getOrCreateSubset('injection', injection_1.default);
    }
    /**
     * Return a Feedback object instance used to interact with the audio feedback API.
     *
     * @returns An Feedback instance, reused from a previous call if possible.
     */
    feedback() {
        return this._getOrCreateSubset('feedback', feedback_1.default);
    }
    /**
     * Return a Tts object instance used to interact with the text to speech API.
     *
     * @returns An Tts instance, reused from a previous call if possible.
     */
    tts() {
        return this._getOrCreateSubset('tts', tts_1.default);
    }
    /**
     * @experimental
     *
     * **Warning: Experimental, use at your own risk!**
     *
     * Returns an Audio object instance used to interact with the audio playback API.
     *
     * @returns An Audio instance, reused from a previous call if possible.
     */
    audio() {
        return this._getOrCreateSubset('audio', audio_1.default);
    }
    /**
     * Disposes the hermes object and its underlying resources.
     */
    destroy() {
        this.activeSubsets.forEach(subset => {
            subset.destroy();
        });
        this.call('hermes_destroy_mqtt_protocol_handler', this.protocolHandler);
    }
    // Private //
    _getOrCreateSubset(key, Class) {
        if (!this.activeSubsets.has(key)) {
            this.activeSubsets.set(key, new Class(this.protocolHandler, this.call, this.options));
        }
        return this.activeSubsets.get(key);
    }
}
exports.Hermes = Hermes;
Hermes.defaultOptions = {
    address: 'localhost:1883',
    logs: false
};
//# sourceMappingURL=index.js.map